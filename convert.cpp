/*
This program is designed to convert the .txt file generated by the web crawler into a formatted .csv file for use by the analyzer.

The program will have multiple stages:

1. Take in and read all data from a .txt file

2. Write data out as a formatted .csv

3. Present menu to allow different stages of data cleaning before writing to .csv

4. Write function that will parse data from full URL to domain URL when corresponding choice is made

5. Write function that will remove tier listings from data vector when corresponding choice is made 

6. Write separate function to write just to text file with data as-is

7. Add option to menu to print size of data set

8. Ask before removing blank lines

9. Fix write_csv to work for links that don't start with http

10. Make write_html function to allow data to be written as raw html file for browsing links

11. Make function to convert duplicates/tocrawl files to csv with occurrence counters

12. Make function to get occurrences of links in duplicates/tocrawl files

13. Make function to check if link already counted


Current Status:
1. Complete
2. Complete
3. Complete
4. Queued
5. Cancelled
6. Complete
7. Complete
8. Complete
9. Complete
10. Complete
11. Complete
12. Complete
13. Complete
*/

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cstdlib>

using namespace std;

//This function will read all data from the input file and store it in a vector of strings
void read(ifstream&, vector <string>&);

//This function will check if link has already been counted
bool find_link(string&, vector<string>&);

//This function will write all data in the vector of strings to the .csv file
void write_csv(ofstream&, vector <string>&);

//This function will write all data to a text file
void write_txt(ofstream&, vector <string>&);

//This function will write all data to a html file
void write_html(ofstream&, vector<string>&);

//This function will convert duplicates/tocrawl files to csv (call count function first)
void convert_csv(ofstream&, vector<string>&, vector<int>&);

//This function with get occurrence counters for duplicate/tocrawl files
void get_occur(vector<string>&, vector<string>&, vector<int>&);

//This function will remove all empty newlines from data set
void remove_blanks(vector <string>&);

//Debug function to print all in the vector
void print(vector <string>&);

//display menu to choose cleaning method
void menu_crawled(vector<string>&);

int main()
{
	ifstream input;
	ofstream output;

	string ifile; //string to hold name of input file
	string ofile; //string to hold name of output file

	vector<string> data;
	vector<int> occur;
	vector<string> counted_data;

	int choice = 0;
	char decide;
	
	int file_type = -1;

	cout << "Cleaner/Converter program for Web Crawler output data." << endl;
	cout << "Program will ask for an input file generated by the web crawler (typically links.txt)." << endl;
	cout << "A menu will be presented asking for what extra cleaning is desired (removal of blank lines is done by default)" << endl;
	cout << "Once the data has been cleaned, enter the file name for output (name.csv) and the data will be written as a formatted csv file." << endl << endl;


	//get name of input file and open
	cout << "Enter name of input file (links.txt): ";
	getline(cin, ifile);
	
	input.open(ifile.c_str());

	if (!input)
	{
		cout << "Could not open file" << endl;
		exit(2);
	}
	////////


	read(input, data); //read data
	
	cout << "Which file is this? " << endl;
	cout << "1. Crawled file" << endl;
	cout << "2. Duplicates file" << endl;
	cout << "3. Tocrawl file" << endl;
	cout << "Choice: ";
	cin >> file_type;
	
	switch(file_type)
	{
		case 1: //if file contains list of crawled links
		{
			cout << "Remove blank lines from file (only needed if running links.txt): ";
			cin >> decide;
			
			if (decide == 'y')
			{
				remove_blanks(data); //basic cleaning
			}
			
			menu_crawled(data); //call menu function to get cleaning choice and confirm
			break;
		}
		case 2: //for duplicate files
		{
			cout << "Converting to .csv file with occurrence counters." << endl;
			get_occur(data, counted_data, occur);
			convert_csv(output, counted_data, occur);
			break;
		}
		case 3: //for tocrawl files
		{
			cout << "Converting to .csv file with occurrence counters." << endl;
			//get_occur(data, counted_data, occur);
			convert_csv(output, counted_data, occur);
			break;
		}
		default:
		{
			cout << "Not a choice." << endl;
			break;
		}
		
	}//end file_type switch
	
	if (file_type == 1) //only need to display following menu if working with crawled links file
	{
		cout << "Write data to new file? ";
		cin >> decide;
		if (decide == 'y')
		{
			cout << "1. Text File" << endl;
			cout << "2. CSV File" << endl;
			cout << "3. HTML File" << endl;
			cout << "Choice: ";
			cin >> choice;
			cin.ignore();
			switch (choice)
			{
				case 1: //write to text file
				{
					cout << "Enter name of output file (name.txt): ";
					getline(cin, ofile);
					
					output.open(ofile.c_str());
					
					write_txt(output, data);
					cout << "Write successful." << endl;
					break;
				}
				case 2: //write to csv file
				{
					//get name of output file and open
					cout << "Enter name of output file (name.csv): ";
					getline(cin, ofile);

					output.open(ofile.c_str());

					write_csv(output, data); //write data
					cout << "Write successful." << endl;
					break;
				}
				case 3: //write to html file
				{
					//get name of output file and open
					cout << "Enter name of output file (name.html): ";
					getline(cin, ofile);

					output.open(ofile.c_str());

					write_html(output, data); //write data
					cout << "Write successful." << endl;
					break;
				}
				default:
				{
					cout << "Not a choice, write cancelled." << endl;
					break;
				}
			}
		}
	}
	
//close files
	input.close();
	output.close();
	cout << "Files closed." << endl;
//pause for review
	cin.ignore();
	cin.ignore();
	return 0;
}

//function read all data from file into vector of strings
void read(ifstream& input, vector<string> &data)
{
	string t;
	getline(input, t); //prime
	while(!input.eof()) //loop until end of file
	{
		data.push_back(t); //add line to vector
		getline(input, t);  //gets each line and stores into data vector
	}
}

//function writes data stored in vector to formatted csv file
void write_csv(ofstream& output, vector<string> &data)
{
	output << "Origin,";
	for(int i = 0; i < data.size(); i++)
	{
		if (isdigit(data[i][0]) && (data[i].find(" from ") != string::npos)) //if a tier lines (starts with a number), output newline first
			output << endl << data[i] << ',';
		else //if a URL, write as-is
			output << data[i] << ',';
	}
}

//function to write data to text file with no formatting
void write_txt(ofstream& output, vector <string> &data)
{
	for(int i = 0; i < data.size(); i++)
	{
		output << data[i] << endl;
	}
}

//function to write data to html file for browsing
void write_html(ofstream& output, vector <string> &data)
{
	cout << "This will not write tier lines if present." << endl;
	output << "<html>" << endl;
	output << "<body>" << endl;
	for (int i = 0; i < data.size(); i++)
	{
		if (isdigit(data[i][0]) && (data[i].find(" from ") != string::npos))
		{
			//if a tier line, do nothing
		}
		else
		{
			output << "<a href=" << '"' << data[i] << '"' << '>' << data[i] << "</a>" << endl;
			output << "<BR>" << endl;
		}
	}
	output << "</body>" << endl;
	output << "</html>" << endl;
}

//function removes blank lines from data set
void remove_blanks(vector<string> &data)
{
	cout << "Removing blank lines from data." << endl;

	bool removed = false;
	int lines= 0;
//search data vector for blank lines and remove them until none are found
	do
	{
		removed = false;
		for(int i = 0; i < data.size(); i++)
		{
			if(data[i] == "")
			{
				//cout << "Found" << endl;
				data.erase(data.begin() + i);
				removed = true;
				lines++;
			}
		}
	}while(removed);

	//data.erase(data.begin() + (data.size() - 1)); //removes trailing line
//output how many blank lines were removed (no real purpose, just fyi)
	cout << "Blank lines removed: " << lines << endl;
}

//function to print data set to screen (for debugging purposes)
void print(vector<string> &data)
{
	for (int i = 0; i < data.size(); i++)
	{
		cout << data[i] << endl;
	}
}

//function to display a menu for extra options
//once an option is chosen, a description of what the option does is given
//after the description, program asks for confirmation of choice
//if confirmed, returns number of option
//else, menu is displayed again until valid option is confirmed or No Cleaning is chosen
void menu_crawled(vector<string> &data)
{
	int choice;
	char confirm = 'n';
	char leave = 'n';
	cout << "Program will ask for confirmation before cleaning. Positive confirmation will exit menu." << endl;
	cout << "Extra cleaning:" << endl;
	cout << "1. Limit to domain" << endl;
	cout << "2. No Cleaning" << endl;

	cin >> choice;

	switch(choice)
	{
	case 1:
		{
			cout << "This option will strip all URLs in the data set to just the domain." << endl;
			cout << "ex. http://www.udacity.com/cs101x/index.html will become http://www.udacity.com/" << endl;
			cout << endl << "Use this option (y/n): ";
			cin >> confirm;
			
			if(confirm == 'y')
			{
				cout << "Need to write domain cleaning function" << endl;
			}
			else
			{
				menu_crawled(data);
			}
			
			break;
		}
	case 2:
		{
			cout << "This option will not do any extra cleaning on the data." << endl;
			cout << endl << "Use this option (y/n): ";
			cin >> confirm;
			
			if (confirm == 'y')
			{
				//dead end, doesn't need to do anything
			}
			else
			{
				menu_crawled(data);
			}
			
			break;
		}
	default:
		{
			cout << "Not a valid option" << endl;
			break;
		}
	}
	/* This is no longer needed
	cout << "Exit menu()? ";
	cin >> leave;
	
	if (leave == 'y')
		return;
	else
		menu_crawled(data); 
	*/
}

//function to determine if current link has already been tallied
bool find_link(string &to_find, vector<string> &check)
{
	for (int i = 0; i < check.size(); i++)
	{
		if (to_find == check[i]) //if link is already in counted vector...
		{
			return true;
		}
	}
	return false; //if link is not already in counted vector...
}

//function to get the occurrence numbers of each link in the file
void get_occur(vector<string> &data, vector<string> &counted, vector<int> &occur)
{
	bool found = false;
	int c = 0;
	string t;
	
	for (int i = 0; i < data.size(); i++)
	{
		found = find_link(data[i], counted); //check if current link has already been counted
		
		if (!found) //if not counted yet
		{
			counted.push_back(data[i]); //append link to vector
			t = data[i]; //store current link
			for (int j = 0; j < data.size(); j++)
			{
				if (data[j] == t) //total up each occurrence of the link
				{
					c++;
				} //close if
			} //close for
		}//close if
		
		if (c != 0) //if at least once instance is present...
		{
			occur.push_back(c); //append link counter to vector
			c = 0; //reset temp counter
		}
	}//close for
}//close occur

//This function takes in the vector of unique links and the occurrence of each to write to a csv file
void convert_csv(ofstream &output, vector<string> &data, vector<int> &occur)
{
	string fname;
	int comma_pos = string::npos; //initialize position for locating url commas
	
	cout << "Enter file name: (name.csv)";
	cin >> fname;
	
	output.open(fname.c_str());
	
	output << ',' << "Link," << "Occurrence," << endl; //write column headers
	for (int i = 0; i < data.size(); i++)
	{
		comma_pos = data[i].find(','); //see if there is a comma in the URL
		
		if (comma_pos != string::npos) //If there is...
		{
			data[i].erase(data[i].begin() + comma_pos); //remove the comma
		}
		
		output << i << ',' << data[i] << ',' << occur[i] << ',' << endl; //write index number, URL, and occurrence count to file
	}
}

